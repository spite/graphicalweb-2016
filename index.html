<!doctype html>
<html lang="en">
<head>

	<meta charset="utf-8">
	<title>World</title>

	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<link href='//fonts.googleapis.com/css?family=Raleway:400,200,600' rel='stylesheet' type='text/css'>

	<style>
		*{box-sizing: border-box; margin: 0; padding: 0; }
		body{ overflow: hidden; }
		#container{ position: absolute; left: 0; top: 0; right: 0; bottom: 0; }
	</style>
</head>
<body>

<ul id="states" ></ul>
<div id="container"></div>

</body>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/pathseg.js"></script>
<script src="js/MapMesh.js"></script>
<script src="js/OBJExporter.js"></script>
<script src="js/CSVToArray.js"></script>
<script src="js/THREE.ConstantSpline.js"></script>
<script src="js/THREE.Text.js"></script>
<script src="js/WebVR.js"></script>
<script src="js/VREffect.js"></script>
<script src="js/VRControls.js"></script>
<script src="js/THREE.FBOHelper.js"></script>

<script id="text-vertex-shader" type="x-shader/x-vertex" >
#define MAX 32
precision highp float;
attribute vec3 position;
attribute float id;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform int string[ MAX ];
uniform float widths[ MAX ];
uniform float lefts[ MAX ];
uniform vec3 dimensions;
varying vec2 vUV;
void main() {
	int iid = int( id );
	float offset = 0.;
	vec3 p = position;
	for( int i = 0; i < MAX; ++i ){
		if( i < iid ) {
			p.x += widths[ i ] + offset;
		}
	}
	if( position.x == 1. ) {
		p.x += widths[ iid ] - 1.;
	}
	p.y = 1. - p.y;
	vUV = position.xy;
	float h = dimensions.z / dimensions.y;
	float c = float( string[ iid ] );
	if( vUV.y == 0. ) {
		vUV.y = floor( c / 10. ) * h;
	}
	if( vUV.y == 1. ) {
		vUV.y = floor( c / 10. ) * h + h;
	}
	vUV.y = 1. - vUV.y;
	if( vUV.x == 0. ) {
		vUV.x = mod( c, 10. ) / 10. + lefts[ iid ] / dimensions.x;
	}
	if( vUV.x == 1. ){
		vUV.x = mod( c, 10. ) / 10. + lefts[ iid ] / dimensions.x + widths[ iid ] / dimensions.x;
	}
	p.y *= dimensions.z;
	p *= .001;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );
}
</script>

<script id="text-fragment-shader" type="x-shader/x-fragment" >
precision highp float;
uniform sampler2D map;
varying vec2 vUV;
void main() {
	vec4 c = texture2D( map, vUV ).rgba;
	gl_FragColor = vec4( c.rgb * vec3( 1., 1., 1. ), c.a );
	//gl_FragColor = vec4( 1., 0., 1., 1. );
}
</script>

<script id="line-vs" type="x-shader/x-vertex" >

precision highp float;

attribute vec3 position;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec2 vUv;

void main() {

	vUv = uv;

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );

}

</script>

<script id="line-fs" type="x-shader/x-fragment" >
precision highp float;

uniform vec3 color;
uniform float opacity;
uniform float time;
uniform float direction;
uniform float width;

varying vec2 vUv;

void main() {

	float c = direction * mod( - .001 * time + abs( .5 - vUv.y ) - mod( vUv.x * 2., 1. ), 1. );

	gl_FragColor = vec4( color, .5 + .5 * c );

}
</script>

<script id="floor-vs" type="x-shader/x-vertex" >
precision highp float;

attribute vec3 position;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

uniform sampler2D floorMap;

varying vec2 vUv;

void main() {

	vUv = uv;

	vec4 c = texture2D( floorMap, uv );
	vec3 dir = normalize( position );

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position - 0. * ( c.r - .5 ) * dir, 1. );

}

</script>

<script id="floor-fs" type="x-shader/x-fragment" >
precision highp float;

uniform sampler2D floorMap;
uniform sampler2D diffuseMap;

varying vec2 vUv;

void main() {

	vec4 d = texture2D( diffuseMap, vUv );
	vec4 h = texture2D( floorMap, vUv );

	vec4 c = mix( vec4( 0., 119., 190., 255. ) / 255. * h.r, d, smoothstep( .45, .55, h.r ) );

	gl_FragColor = vec4( c.rgb, 1. );

}

</script>

<script>

	'use strict'

	var regions = {
		'Africa': { color: new THREE.Color( 0xfec92e ) },
		'Latin America': { color: new THREE.Color( 0xfec92e ) },
		'North America': { color: new THREE.Color( 0xcb3e1a ) },
		'West Asia': { color: new THREE.Color( 0xb41174 ) },
		'South Asia': { color: new THREE.Color( 0x245aa3 ) },
		'East Asia': { color: new THREE.Color( 0x18a492 ) },
		'South-East Asia': { color: new THREE.Color( 0x159c41 ) },
		'Former Soviet Union': { color: new THREE.Color( 0x674290 ) },
		'Europe': { color: new THREE.Color( 0x6fac34 ) },
		'Oceania': { color: new THREE.Color( 0x3b8874 ) },
	};

	var subregions = {
		'Australia and New Zealand': 'Oceania',
		'Caribbean': 'Latin America',
		'Central America': 'Latin America',
		'Central Asia': 'Former Soviet Union',
		'Central Europe': 'Europe',
		'Eastern Africa': 'Africa',
		'Eastern Asia': 'East Asia',
		'Eastern Europe': 'Former Soviet Union',
		'Melanesia': 'Oceania',
		'Micronesia': 'Oceania',
		'Middle Africa': 'Africa',
		'Northern Africa': 'Africa',
		'Northern America': 'North America',
		'Northern Europe': 'Europe',
		'Polynesia': 'Oceania',
		'South America': 'Latin America',
		'South-Eastern Asia': 'South-East Asia',
		'Southern Africa': 'Africa',
		'Southern Asia': 'South Asia',
		'Southern Europe': 'Europe',
		'Western Africa': 'Africa',
		'Western Asia': 'West Asia',
		'Western Europe': 'Europe'
	};

	var atlasRobotoCondensed;

	var effect;

	var container = document.getElementById( 'container' );

	var composer;
	var FXAAPass, noisePass, rgbSplitPass;
	var raycaster = new THREE.Raycaster();
	var centerVector = new THREE.Vector2( 0, 0 );

	var scene, camera, hitCamera, controls, renderer;
	var hitScene;
	var map;
	var raycaster = new THREE.Raycaster();
	var light1, light2, helper;

	var depthMaterial = new THREE.MeshBasicMaterial();
	var depthTexture = null;

	var world = new THREE.Object3D();
	var codes = new Map();

	var hitTexture = new THREE.WebGLRenderTarget( 1,1  );
	hitTexture.texture.minFilter = THREE.NearestFilter;
	hitTexture.texture.magFilter = THREE.NearestFilter;
	hitTexture.generateMipMaps = false;
	hitTexture.flipY = true;

	var hoveredCountry = null, currentCountry = null;

	var fboHelper;

	function init() {

		scene = new THREE.Scene();
		hitScene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 75, 1, .01, 3000 );
		camera.target = new THREE.Vector3();
		camera.position.set( 0, 0, 0.0001 );

		hitCamera = new THREE.PerspectiveCamera( .001, 1, .01, 3000 );

		renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
		container.appendChild( renderer.domElement );
		var pixelRatioScale = 1;
		renderer.setPixelRatio( pixelRatioScale * window.devicePixelRatio );
		renderer.setClearColor( 0 );

		atlasRobotoCondensed = new THREE.FontAtlas( {
			renderer: renderer,
			size: 160,
			fontName: 'Roboto Condensed',
			woffSrc: 'url(https://fonts.gstatic.com/s/robotocondensed/v13/Zd2E9abXLFGSr9G3YK2MsNxB8OB85xaNTJvVSB9YUjQ.woff)',
			woff2Src: 'url(https://fonts.gstatic.com/s/robotocondensed/v13/Zd2E9abXLFGSr9G3YK2MsIPxuqWfQuZGbz5Rz4Zu1gk.woff2)'
		} );

		fboHelper = new FBOHelper( renderer );
		fboHelper.attach( hitTexture, 'HitMap' );

		//controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls = new THREE.VRControls( camera );

		effect = new THREE.VREffect( renderer );

		if ( navigator.getVRDisplays ) {

			navigator.getVRDisplays()
			.then( function ( displays ) {
				effect.setVRDisplay( displays[ 0 ] );
				controls.setVRDisplay( displays[ 0 ] );
			} )
			.catch( function () {
				// no displays
			} );

			document.body.appendChild( WEBVR.getButton( effect ) );

		}

		scene.add( world );

		window.addEventListener( 'resize', onWindowResize );

		onWindowResize();

		container.addEventListener( 'mousedown', function( e ) {
			hitTest();
			if( hoveredCountry !== null ) {
				currentCountry = hoveredCountry;
				createConnections( currentCountry );
			}
		} )

		loadMap();

	}

	var countriesData, mapData, migrationData, inData, outData;

	function createCountriesMap( data ) {

		var map = new Map();

		data.forEach( c => {
			map.set( c.cca3, c );
		} );

		return map;

	}

	function loadMap() {

		Promise.all( [
		    fetch( 'assets/BlankMap-Equirectangular.svg' )
		    	.then( res => res.text() )
		    	.then( res => {
		    		return Promise.all( [
		    			drawSVG( res )
		    				.then( res => mapData = res ),
		    			createWorldMask( res )
		    		] )
		    	} ),
		    fetch( 'assets/data.csv' )
		    	.then( res => res.text() )
		    	.then( res => parseData( res ) )
		    	.then( res => [ inData, outData ] = res ),
			fetch( 'assets/countries.json' )
				.then( res => res.json() )
				.then( res => createCountriesMap( res ) )
				.then( res => countriesData = res )
		] ).then( _ => buildMap() ).then( _ => render() );

	}

	function createWorldMask( source ) {

		return new Promise( ( resolve, reject ) => {

			var d = new DOMParser();
			var doc = d.parseFromString( source, "image/svg+xml");
			var countries = doc.querySelectorAll( '.country path' );
			[].forEach.call( countries, function( l, i ) {
				l.setAttribute( 'fill', 'rgb(255,0,' + i + ')' );
				l.setAttribute( 'stroke', 'rgb(255,0,' + i + ')' );
				l.setAttribute( 'stroke-width', 0 );
				codes.set( i, l.parentNode.className.baseVal.replace( 'country ', '' ) );
			} );
			//var src = doc.children[ 0 ].outerHTML; // works on FF & Ch

			var oSerializer = new XMLSerializer();
			var src = oSerializer.serializeToString(doc);

			var img = new Image();
			var svg = new Blob([ src ], {type: 'image/svg+xml;charset=utf-8'});
			var DOMURL = window.URL || window.webkitURL || window;
			var url = DOMURL.createObjectURL(svg);

			img.onload = function () {

				var canvas = document.createElement( 'canvas' );
				var ctx = canvas.getContext( '2d' );
				canvas.width = 4096;
				canvas.height = 2048;
				ctx.drawImage( img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height );
				DOMURL.revokeObjectURL( url );

				var texture = new THREE.Texture( canvas );
				texture.needsUpdate = true;

				var mesh = new THREE.Mesh(
					new THREE.IcosahedronGeometry( 5, 6 ),
					new THREE.MeshBasicMaterial( { map: texture, side: THREE.DoubleSide } )
				);
				hitScene.add( mesh );
				mesh.scale.x = -1;

				console.log( 'createworldmask' )
				resolve();

			}

			img.src = url;

			//createTextLabels();
		} );

	}

	var globalMax = 0;
	var globalMin = 10000000000;

	function parseData( data ) {

		// region_orig, region_orig_id
		// region_dest, region_dest_id
		// country_orig, country_orid_id
		// country_dest, country_dest_id
		// region_flow_1990, regionflow_1995, region_flow_2000, region_flow_2005
		// country_flow_1990, country_flow_1995, country_flow_2000, country_flow_2005
		// metadata

		var inMap = new Map();
		var outMap = new Map();
		var inData = CSVToArray( data, ',' )
		var outData = CSVToArray( data, ',' )
		//addUI();

		inData.forEach( s => {

			s[ 8 ] = parseInt( s[ 18 ], 10 );
			s[ 9 ] = parseInt( s[ 9 ], 10 );
			s[ 10 ] = parseInt( s[ 10 ], 10 );
			s[ 11 ] = parseInt( s[ 11 ], 10 );

			s[ 12 ] = parseInt( s[ 12 ], 10 );
			s[ 13 ] = parseInt( s[ 13 ], 10 );
			s[ 14 ] = parseInt( s[ 14 ], 10 );
			s[ 15 ] = parseInt( s[ 15 ], 10 );

			if( s[ 15 ] > globalMax ) globalMax = s[ 15 ];
			if( s[ 15 ] < globalMin ) globalMin = s[ 15 ]

		} );

		var globalRange = globalMax - globalMin;

		inData.forEach( s => {

			if( !outMap.has( s[ 5 ] ) ) {
				outMap.set( s[ 5 ], new Map() );
			}
			outMap.get( s[ 5 ] ).set( s[ 7 ], ( s[ 15 ] - globalMin ) / globalRange );

			if( !inMap.has( s[ 7 ] ) ) {
				inMap.set( s[ 7 ], new Map() );
			}
			inMap.get( s[ 7 ] ).set( s[ 5 ], ( s[ 15 ] - globalMin ) / globalRange );

		} );

		return [ inMap, outMap ];

	}

	function latLngToVec3( lat, lon ) {

		lat = Math.max( - 85, Math.min( 85, lat ) );
		var phi = ( 90 - lat ) * Math.PI / 180;
		var theta = ( 180 - lon ) * Math.PI / 180;
		var d = 5;
		var x = -d * Math.sin( phi ) * Math.cos( theta );
		var y = d * Math.cos( phi );
		var z = d * Math.sin( phi ) * Math.sin( theta );

		return new THREE.Vector3( x, y, z );

	}

	function addTriangle( points, buffer, t ) {

		for( var j = 0; j < points.length; j++ ) {

			buffer[ t + 0 ] = points[ j ].x;
			buffer[ t + 1 ] = points[ j ].y;
			buffer[ t + 2 ] = points[ j ].z;

			t += 3;

		}

		return t;

	}

	function addUV( points, buffer, t ) {

		for( var j = 0; j < points.length; j++ ) {

			buffer[ t + 0 ] = points[ j ].x;
			buffer[ t + 1 ] = points[ j ].y;

			t += 2;

		}

		return t;

	}

	function join( a, b, w ) {

		var from = latLngToVec3( a.lat, a.lon ),
			to = latLngToVec3( b.lat, b.lon );

		var dir = to.clone().sub( from ).normalize();
		var d = from.distanceTo( to );

		var s = new THREE.ConstantSpline()

		s.p0 = from.clone();
		s.p1 = from.clone().add( from.clone().normalize().multiplyScalar( -.5 * d ) );
		s.p2 = to.clone().add( to.clone().normalize().multiplyScalar( -.5 * d ) );
		s.p3 = to.clone();

		var perpendicular = s.p1.clone().normalize().cross( dir );
		perpendicular.normalize().multiplyScalar( .05 * d );
		s.p1.add( perpendicular );
		s.p2.add( perpendicular );

		s.calculate();

		var geometry = new THREE.Geometry();

		s.calculateDistances();
		s.reticulate( { distancePerStep: .2 } );

	 	var geometry = new THREE.BufferGeometry();

		var triangles = s.lPoints.length;
		var positions = new Float32Array( triangles * 3 * 3 * 2 );
		var uvs = new Float32Array( triangles * 3 * 2 * 2 );

		var p0 = s.lPoints[ 0 ];
		var p1 = s.lPoints[ s.lPoints.length - 1 ];
		var d = p1.clone().sub( p0 ).normalize();
		var up = p0.clone().normalize();
		var p = up.cross( d ).normalize();

		var t = 0;
		var t2 = 0;

		var o = 0;//j / s.lPoints.length;
		var i = 1;//1 / s.lPoints.length;
		var ua = new THREE.Vector2( o, 0 );
		var ub = new THREE.Vector2( o + i, 0 );
		var uc = new THREE.Vector2( o, 1 );
		var ud = new THREE.Vector2( o + i, 1 );

		for( var j = 0; j < s.lPoints.length - 1; j++ ) {

			var from = s.lPoints[ j ];
			var to = s.lPoints[ j + 1 ];

			var pScaled1 = p.clone().multiplyScalar( j * w / s.lPoints.length );
			var pScaled2 = p.clone().multiplyScalar( ( j + 1 ) * w / s.lPoints.length );
			var a = from.clone().sub( pScaled1 );
			var b = to.clone().sub( pScaled2 );
			var c = from.clone().add( pScaled1 );
			var d = to.clone().add( pScaled2 );

			t = addTriangle( [ a, b, c ], positions, t );
			t = addTriangle( [ d, c, b ], positions, t );

			t2 = addUV( [ ua, ub, uc ], uvs, t2 );
			t2 = addUV( [ ud, uc, ub ], uvs, t2 );

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return geometry;

	}

	var lineMaterial = new THREE.RawShaderMaterial( {
		uniforms: {
			color: { type: 'c', value: new THREE.Color( 0xffba00 ) },
			opacity: { type: 'f', value: .5 },
			time: { type: 'f', value: 0 },
			direction: { type: 'f', value: 0 },
			width: { type: 'f', value: 0 }
		},
		transparent: true,
		side: THREE.DoubleSide,
		depthWrite: false,
		vertexShader: document.getElementById( 'line-vs' ).textContent,
		fragmentShader: document.getElementById( 'line-fs' ).textContent
	} );

	var linesObject = new THREE.Object3D();
	world.add( linesObject );

	function createConnections( country ) {

		while( linesObject.children.length ) linesObject.remove( linesObject.children[ 0 ] )
		countriesData.forEach( c => { if( c.label ) c.label.mesh.visible = false; } );

		var cty = countriesData.get( country );
		cty.label.mesh.visible = true;
		var from = cty.latlng;
		var w = .5;
		var min = .01;

		inData.get( country ).forEach( ( amount, toCountry ) => {

			if( amount > min ) {
				var c = countriesData.get( toCountry );
				if( c ) {
					if( c.label ) c.label.mesh.visible = true;
					var to = c.latlng;
					var g = join( { lat: from[ 0 ], lon: from[ 1 ] }, { lat: to[ 0 ], lon: to[ 1 ] }, w * amount );
					var mat = lineMaterial.clone();
					mat.uniforms.color.value.copy( regions[ subregions[ c.subregion ] ].color );
					mat.uniforms.opacity.value = amount;
					mat.uniforms.width.value = w * amount;
					mat.uniforms.direction.value = -1;
					var line = new THREE.Mesh( g, mat );
					linesObject.add( line );
				} else {
					console.log( 'Missing country ', toCountry );
				}
			}

		} );

		outData.get( country ).forEach( ( amount, toCountry ) => {

			if( amount > min ) {
				var c = countriesData.get( toCountry );
				if( c ) {
					if( c.label ) c.label.mesh.visible = true;
					var to = c.latlng;
					var g = join( { lat: to[ 0 ], lon: to[ 1 ] }, { lat: from[ 0 ], lon: from[ 1 ] }, w * amount );
					var mat = lineMaterial.clone();
					mat.uniforms.color.value.copy( regions[ subregions[ c.subregion ] ].color );
					mat.uniforms.opacity.value = amount;
					mat.uniforms.width.value = w * amount;
					mat.uniforms.direction.value = 1;
					var line = new THREE.Mesh( g, mat );
					linesObject.add( line );
				} else {
					console.log( 'Missing country ', toCountry );
				}
			}

		} );

		invalidate = true;

	}

	function toASCII(s){
		var r = s.toLowerCase();
		var non_asciis = {'a': '[àáâãäå]', 'ae': 'æ', 'c': 'ç', 'e': '[èéêë]', 'i': '[ìíîï]', 'n': 'ñ', 'o': '[òóôõö]', 'oe': 'œ', 'u': '[ùúûűü]', 'y': '[ýÿ]'};
		for ( var i in non_asciis) { r = r.replace(new RegExp(non_asciis[i], 'g'), i); }
			return r;
	};


	function buildMap() {

		var material = new THREE.LineBasicMaterial( { linewidth: 1 });
		var min = 10000000, max = -10000000;

		var lines = 0;
		mapData.forEach( ( territory, id ) => {

			territory.forEach( path => {

				path.lines.forEach( line => {

					lines += line.length;

				} );

			} );

		} );

		var lineGeometry = new THREE.BufferGeometry();
		var positions = new Float32Array( lines * 2 * 3 );
		var ptr = 0;

		mapData.forEach( ( territory, id ) => {

			var territoryGeometry = new THREE.BufferGeometry();

			territory.forEach( path => {

				path.lines.forEach( line => {

					for( var j = 0; j < line.length - 1; j++ ) {

						var p = line[ j ];
						if( p.y < min ) min = p.y;
						if( p.y > max ) max = p.x;

						var res = latLngToVec3( p.y, p.x );

						positions[ ptr ] = res.x;
						positions[ ptr + 1 ] = res.y;
						positions[ ptr + 2 ] = res.z;

						ptr += 3;

						var p = line[ j + 1 ];

						var res = latLngToVec3( p.y, p.x );

						positions[ ptr ] = res.x;
						positions[ ptr + 1 ] = res.y;
						positions[ ptr + 2 ] = res.z;

						ptr += 3;

					}

					var capital = countriesData.get( id );
					if( capital ) {

						var res = latLngToVec3( capital.latlng[ 0 ], capital.latlng[ 1 ] );

						var sphere = new THREE.Mesh(
							new THREE.BoxBufferGeometry( .1, .1, .1 ),
							new THREE.MeshBasicMaterial( { color: 0x0ff00ff })
						)
						sphere.position.copy( res );
						//world.add( sphere );

						var label = new THREE.Text( atlasRobotoCondensed );
						label.set( toASCII( capital.name.common ).toUpperCase() );
						label.mesh.position.copy( res );
						label.mesh.lookAt( world.position )
						world.add( label.mesh );
						label.mesh.visible = false;
						capital.label = label;

					} else {
						console.log( id + ' not found')
					}

				})

			} );

		} );

		lineGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		lineGeometry.computeBoundingSphere();

		var mesh = new THREE.LineSegments( lineGeometry, material );
		mesh.fustrumCulled = false;
		world.add( mesh );

		invalidate = true;

		createConnections( 'GBR' );

		/*var exporter = new THREE.OBJExporter();
		var result = exporter.parse( scene );

		var blobModel = new Blob( [ result ], { type: 'text/plain' } );
		var url = URL.createObjectURL( blobModel );

		window.location = url;*/

		var geometry = new THREE.IcosahedronGeometry( 5, 6 );

		var loader = new THREE.TextureLoader()
		var heightMap = loader.load( 'assets/bathymetry_bw_composite_4k.jpg', _ => invalidate = true );
		var diffuseMap = loader.load( 'assets/bathymetry_diffuse_4k.jpg', _ => invalidate = true );

		var material = new THREE.RawShaderMaterial( {
			uniforms: {
				diffuseMap: { type: 't', value: diffuseMap },
				floorMap: { type: 't', value: heightMap }
			},
			vertexShader: document.getElementById( 'floor-vs' ).textContent,
			fragmentShader: document.getElementById( 'floor-fs' ).textContent,
			wireframe: !true,
			depthWrite: false,
			side: THREE.DoubleSide
		} );

		var mesh = new THREE.Mesh( geometry, material );
		mesh.scale.x = -1
		world.add( mesh );

	}

	var hash = null;
	var invalidate = true;
	var pixelBuffer = new Uint8Array( 4 );

	function hashCamera() {

		return `${camera.position.x}|${camera.position.y}|${camera.position.z}|${camera.rotation.x}|${camera.rotation.y}|${camera.rotation.z}`
	}

	var counter = 0;

	function hitTest() {

		performance.mark( 'start' );
		renderer.readRenderTargetPixels( hitTexture, 0, 0, 1, 1, pixelBuffer );
		if( pixelBuffer[ 3 ] === 255 ) {
			if( pixelBuffer[ 0 ] === 255 ) {
				hoveredCountry = codes.get( pixelBuffer[ 2 ] )
				console.log( hoveredCountry );
			}
		} else {
			hoveredCountry = null;
		}
		performance.mark( 'end' );
		performance.measure( 'readpixels', 'start', 'end' );

		renderer.render( hitScene, hitCamera, hitTexture );

	}

	window.addEventListener( 'vrdisplaypresentchange', _ => invalidate = true );

	function render( timestamp ) {

		controls.update();
		var newHash = hashCamera();
		if( hash != newHash ){
			invalidate = true;
			hash = newHash
		}

		hitCamera.position.copy( camera.position );
		hitCamera.rotation.copy( camera.rotation );

		var t = performance.now();
		linesObject.children.forEach( l => l.material.uniforms.time.value = t );

		if( invalidate ) {

			effect.render( scene, camera );
			//invalidate = false;

		}

		fboHelper.update();

		effect.requestAnimationFrame( render );

	}

	function onWindowResize() {

		effect.setSize( container.clientWidth, container.clientHeight );
		camera.aspect = container.clientWidth / container.clientHeight;
		camera.updateProjectionMatrix();

		fboHelper.setSize( container.clientWidth, container.clientHeight );
		hitTexture.setSize( 1, 1 );
		fboHelper.refreshFBO( hitTexture );

		invalidate = true;

	}

	window.addEventListener( 'load', init );

</script>
</html>
