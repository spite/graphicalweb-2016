<!doctype html>
<html lang="en">
<head>

	<meta charset="utf-8">
	<title>World</title>

	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<link href='//fonts.googleapis.com/css?family=Raleway:400,200,600' rel='stylesheet' type='text/css'>

	<style>
		*{box-sizing: border-box; margin: 0; padding: 0; }
		body{ overflow: hidden; }
	</style>
</head>
<body>

<ul id="states" ></ul>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/pathseg.js"></script>
<script src="js/MapMesh.js"></script>
<script src="js/THREE.MeshLine.js"></script>
<script src="js/OBJExporter.js"></script>
<script src="js/CSVToArray.js"></script>
<script src="js/THREE.ConstantSpline.js"></script>
<script src="js/WebVR.js"></script>
<script src="js/VREffect.js"></script>
<script src="js/VRControls.js"></script>

<script src="Wagner/Wagner.js"></script>
<script src="Wagner/Wagner.base.js"></script>
<script src="Wagner/ShaderLoader.js"></script>

<script id="floor-vs" type="x-shader/x-vertex" >
precision highp float;

attribute vec3 position;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

uniform sampler2D floorMap;

varying vec2 vUv;

void main() {

	vUv = uv;

	vec4 c = texture2D( floorMap, uv );
	vec3 dir = normalize( position );

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position - 0. * ( c.r - .5 ) * dir, 1. );

}

</script>

<script id="floor-fs" type="x-shader/x-fragment" >
precision highp float;

uniform sampler2D floorMap;
uniform sampler2D diffuseMap;

varying vec2 vUv;

void main() {

	vec4 d = texture2D( diffuseMap, vUv );
	vec4 h = texture2D( floorMap, vUv );

	vec4 c = mix( vec4( 0., 119., 190., 255. ) / 255. * h.r, d, smoothstep( .45, .55, h.r ) );

	gl_FragColor = vec4( c.rgb, 1. );

}

</script>

<script>

	'use strict'

	WAGNER.vertexShadersPath = 'Wagner/vertex-shaders';
	WAGNER.fragmentShadersPath = 'Wagner/fragment-shaders';
	WAGNER.assetsPath = 'Wagner/assets/';

	/*WAGNER.BokehPoisonPass = function() {

		WAGNER.Pass.call( this );
		WAGNER.log( 'BokehPoison Pass constructor' );
		this.loadShader( 'bokeh-poison-dof-fs.glsl' );

		this.params.amount = 10;
		this.params.radius = 1;
		this.params.tBias = null
		this.params.focalDistance = 1;
		this.params.aperture = 1;

	};

	WAGNER.BokehPoisonPass.prototype = Object.create( WAGNER.Pass.prototype );

	WAGNER.BokehPoisonPass.prototype.run = function( c ) {

		this.shader.uniforms.amount.value = this.params.amount;
		this.shader.uniforms.radius.value = this.params.radius;
		this.shader.uniforms.focalDistance.value = this.params.focalDistance;
		this.shader.uniforms.aperture.value = this.params.aperture;
		this.shader.uniforms.tBias.value = this.params.tBias;
		c.pass( this.shader );

	};*/

	var effect;

	var composer;
	var FXAAPass, DOFPass, noisePass, rgbSplitPass;
	var raycaster = new THREE.Raycaster();
	var centerVector = new THREE.Vector2( 0, 0 );

	var focalDistance = 0;
	var nFocalDistance = 0;

	var scene, camera, controls, renderer, controls;
	var map;
	var raycaster = new THREE.Raycaster();
	var light1, light2, helper;

	var material = new THREE.MeshStandardMaterial( { color: 0xffffff, metalness: 1, roughness: .8 } );
	//material = new THREE.MeshNormalMaterial();
	var statesDiv = document.getElementById( 'states' );
	var nTarget = new THREE.Vector3( 0, 0, 0 );
	var nPosition = new THREE.Vector3( 0, 500, 100 );

	var stateMeshes = {}

	var depthMaterial = new THREE.MeshBasicMaterial();
	var depthTexture = null;

	var world = new THREE.Object3D();

	/*var sL = new ShaderLoader()
	sL.add( 'depth-vs', 'bower_components/Wagner/vertex-shaders/packed-depth-vs.glsl' );
	sL.add( 'depth-fs', 'bower_components/Wagner/fragment-shaders/packed-depth-fs.glsl' );
	sL.load();
	sL.onLoaded( function() {
		depthMaterial = new THREE.ShaderMaterial( {
			uniforms: {
				mNear: { type: 'f', value: camera.near },
				mFar: { type: 'f', value: camera.far }
			},
			vertexShader: this.get( 'depth-vs' ),
			fragmentShader: this.get( 'depth-fs' ),
			shading: THREE.SmoothShading,
			side: THREE.DoubleSide
		} );
	} );*/

	function init() {

		scene = new THREE.Scene();
		var aspectRatio = window.innerWidth / window.innerHeight;
		camera = new THREE.PerspectiveCamera( 75, aspectRatio, .01, 3000 );
		camera.target = new THREE.Vector3();
		camera.position.set( 0, 0, 0.0001 );
		//camera.position.set( 100, 100, 100 );

		renderer = new THREE.WebGLRenderer( { antialias: true });
		document.body.appendChild( renderer.domElement );
		var pixelRatioScale = 1;
		renderer.setPixelRatio( pixelRatioScale * window.devicePixelRatio );
		renderer.setClearColor( 0 );

		composer = new WAGNER.Composer( renderer, { useRGBA: false } );
		//vignettePass = new WAGNER.Vignette2Pass();
		//vignettePass.params.reduction = 2;
		FXAAPass = new WAGNER.FXAAPass();
		//DOFPass = new WAGNER.BokehPoisonPass();
		//DOFPass.params.focalDistance = .5;
		DOFPass = new WAGNER.DOFPass();
		DOFPass.params.aperture = .1;
		DOFPass.params.blurAmount = .1;

		noisePass = new WAGNER.NoisePass();
		noisePass.params.amount = .01;

		rgbSplitPass = new WAGNER.RGBSplitPass();
		rgbSplitPass.params.delta.set( pixelRatioScale * 20, pixelRatioScale * 20 );

		//controls = new THREE.OrbitControls( camera );
		controls = new THREE.VRControls( camera );

		effect = new THREE.VREffect( renderer );

		if ( navigator.getVRDisplays ) {

			navigator.getVRDisplays()
			.then( function ( displays ) {
				effect.setVRDisplay( displays[ 0 ] );
				controls.setVRDisplay( displays[ 0 ] );
			} )
			.catch( function () {
							// no displays
			} );

			document.body.appendChild( WEBVR.getButton( effect ) );

		}

		scene.add( world );
		//world.rotation.y = .1;
		//world.rotation.x = Math.PI / 2;
		//world.scale.x = -1;

		window.addEventListener( 'resize', onWindowResize );

		onWindowResize();

		window.addEventListener( 'keydown', function( e ) {
			/*if( e.keyCode == 32 ) {
				startTime = Date.now();
				audio.currentTime = 0;
			}*/
		} )

		var s = 2048;

		light1 = new THREE.SpotLight( 0xffffff );
		light1.position.set( -100, 300, -100 );
		light1.penumbra = .25
		scene.add( light1 );

		light1.shadow.mapSize.width = s;
		light1.shadow.mapSize.height = s;

		light1.shadow.camera.near = 1;
		light1.shadow.camera.far = 400;
		light1.shadow.bias = -.0000025
		light1.castShadow = true;

		light2 = new THREE.SpotLight( 0xffffff );
		light2.position.set( 300, 300, 100 );
		light2.penumbra = .25
		scene.add( light2 );

		light2.shadow.mapSize.width = s;
		light2.shadow.mapSize.height = s;

		light2.shadow.camera.near = 1;
		light2.shadow.camera.far = 400;
		light2.shadow.bias = -.000005
		light2.castShadow = true;

		renderer.shadowMap.type = THREE.PCFSoftShadowMap
		renderer.shadowMap.enabled = true;

		render();
		loadMap();

	}

	var countriesData, mapData, migrationData, inData, outData;

	function createCountriesMap( data ) {

		var map = new Map();

		data.forEach( c => {
			map.set( c.cca3, c );
		} );

		return map;

	}

	function loadMap() {

		Promise.all( [
		    fetch( 'assets/BlankMap-Equirectangular.svg' )
		    	.then( res => res.text() )
		    	.then( res => {
		    		return Promise.all( [
		    			drawSVG( res )
		    				.then( res => mapData = res ),
		    			createWorldMask( res )
		    		] )
		    	} ),
		    fetch( 'assets/data.csv' )
		    	.then( res => res.text() )
		    	.then( res => parseData( res ) )
		    	.then( res => [ inData, outData ] = res ),
			fetch( 'assets/countries.json' )
				.then( res => res.json() )
				.then( res => createCountriesMap( res ) )
				.then( res => countriesData = res )
		] ).then( _ => buildMap() );

	}

	function createWorldMask( source ) {

		return new Promise( ( resolve, reject ) => {

			var d = new DOMParser();
			var doc = d.parseFromString( source, "image/svg+xml");
			var countries = doc.querySelectorAll( '.country path' );
			[].forEach.call( countries, function( l, i ) {
				l.setAttribute( 'fill', 'rgb(255,0,' + i + ')' );
				l.setAttribute( 'stroke', 'rgb(255,0,' + i + ')' );
				l.setAttribute( 'stroke-width', 0 );
				/*codes[ i ] = {
					id: l.getAttribute( 'id' ),
					name: l.getAttribute( 'title' )
				}*/
			} );
			//var src = doc.children[ 0 ].outerHTML; // works on FF & Ch

			var oSerializer = new XMLSerializer();
			var src = oSerializer.serializeToString(doc);

			var img = new Image();
			var svg = new Blob([ src ], {type: 'image/svg+xml;charset=utf-8'});
			var DOMURL = window.URL || window.webkitURL || window;
			var url = DOMURL.createObjectURL(svg);

			img.onload = function () {

				var canvas = document.createElement( 'canvas' );
				var ctx = canvas.getContext( '2d' );
				canvas.width = 4096;
				canvas.height = 2048;
				ctx.drawImage( img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height );
				DOMURL.revokeObjectURL( url );

				var texture = new THREE.Texture( canvas );
				texture.needsUpdate = true;

				var mesh = new THREE.Mesh(
					new THREE.IcosahedronGeometry( 5, 6 ),
					new THREE.MeshBasicMaterial( { map: texture, side: THREE.DoubleSide } )
				);
				//scene.add( mesh );
				mesh.scale.x = -1;

				console.log( 'createworldmask' )
				resolve();

			}

			img.src = url;

			//createTextLabels();
		} );

	}

	var globalMax = 0;
	var globalMin = 10000000000;

	function parseData( data ) {

		// region_orig, region_orig_id
		// region_dest, region_dest_id
		// country_orig, country_orid_id
		// country_dest, country_dest_id
		// region_flow_1990, regionflow_1995, region_flow_2000, region_flow_2005
		// country_flow_1990, country_flow_1995, country_flow_2000, country_flow_2005
		// metadata

		var inMap = new Map();
		var outMap = new Map();
		var inData = CSVToArray( data, ',' )
		var outData = CSVToArray( data, ',' )
		//addUI();

		inData.forEach( s => {

			s[ 8 ] = parseInt( s[ 18 ], 10 );
			s[ 9 ] = parseInt( s[ 9 ], 10 );
			s[ 10 ] = parseInt( s[ 10 ], 10 );
			s[ 11 ] = parseInt( s[ 11 ], 10 );

			s[ 12 ] = parseInt( s[ 12 ], 10 );
			s[ 13 ] = parseInt( s[ 13 ], 10 );
			s[ 14 ] = parseInt( s[ 14 ], 10 );
			s[ 15 ] = parseInt( s[ 15 ], 10 );

			if( !inMap.has( s[ 5 ] ) ) {
				inMap.set( s[ 5 ], new Map() );
			}
			inMap.get( s[ 5 ] ).set( s[ 7 ], s[ 15 ] );

			if( !outMap.has( s[ 7 ] ) ) {
				outMap.set( s[ 7 ], new Map() );
			}
			outMap.get( s[ 7 ] ).set( s[ 5 ], s[ 15 ] );

			//console.log( s[ 0 ], s[ 1 ], ' | ', s[ 2 ], s[ 3 ], ' - ', s[ 4 ], s[ 5 ], ' | ', s[ 6 ], s[ 7 ] );

		} );

		return [ inMap, outMap ];

	}

	function latLngToVec3( lat, lon ) {

		lat = Math.max( - 85, Math.min( 85, lat ) );
		var phi = ( 90 - lat ) * Math.PI / 180;
		var theta = ( 180 - lon ) * Math.PI / 180;
		var d = 5;
		var x = -d * Math.sin( phi ) * Math.cos( theta );
		var y = d * Math.cos( phi );
		var z = d * Math.sin( phi ) * Math.sin( theta );

		return new THREE.Vector3( x, y, z );

	}

	function addTriangle( points, buffer, t ) {

		for( var j = 0; j < points.length; j++ ) {

			buffer[ t + 0 ] = points[ j ].x;
			buffer[ t + 1 ] = points[ j ].y;
			buffer[ t + 2 ] = points[ j ].z;

			t += 3;

		}

		return t;

	}

	function join( a, b, w ) {

		var from = latLngToVec3( a.lat, a.lon ),
			to = latLngToVec3( b.lat, b.lon );

		var dir = to.clone().sub( from ).normalize();
		var d = from.distanceTo( to );

		var s = new THREE.ConstantSpline()

		s.p0 = from.clone();
		s.p1 = from.clone().add( from.clone().normalize().multiplyScalar( -.5 * d ) );
		s.p2 = to.clone().add( to.clone().normalize().multiplyScalar( -.5 * d ) );
		s.p3 = to.clone();

		var perpendicular = s.p1.clone().normalize().cross( dir );
		perpendicular.normalize().multiplyScalar( .05 * d );
		s.p1.add( perpendicular );
		s.p2.add( perpendicular );

		s.calculate();

		var geometry = new THREE.Geometry();

		s.calculateDistances();
		s.reticulate( { distancePerStep: .4 } );

	 	var geometry = new THREE.BufferGeometry();

		var triangles = s.lPoints.length;
		var positions = new Float32Array( triangles * 3 * 3 * 2 );
		var colors = new Float32Array( triangles * 3 * 3 * 2 );

		var p0 = s.lPoints[ 0 ];
		var p1 = s.lPoints[ s.lPoints.length - 1 ];
		var d = p1.clone().sub( p0 ).normalize();
		var up = p0.clone().normalize();
		var p = up.cross( d ).normalize();

		var t = 0;
		for( var j = 0; j < s.lPoints.length - 1; j++ ) {

			var from = s.lPoints[ j ];
			var to = s.lPoints[ j + 1 ];

			var pScaled1 = p.clone().multiplyScalar( j * w / s.lPoints.length );
			var pScaled2 = p.clone().multiplyScalar( ( j + 1 ) * w / s.lPoints.length );
			var a = from.clone().sub( pScaled1 );
			var b = to.clone().sub( pScaled2 );
			var c = from.clone().add( pScaled1 );
			var d = to.clone().add( pScaled2 );

			t = addTriangle( [ a, b, c ], positions, t );
			t = addTriangle( [ d, c, b ], positions, t );

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		return geometry;

	}

	var lineInMaterial = new THREE.MeshBasicMaterial( {
		color: 0xffba00,
		opacity: .5,
		transparent: true,
		side: THREE.DoubleSide,
		wireframe: !true
	} );

	var lineOutMaterial = new THREE.MeshBasicMaterial( {
		color: 0x00ff72,
		opacity: .5,
		transparent: true,
		side: THREE.DoubleSide,
		wireframe: !true
	} );

	function createConnections( country ) {

		var from = countriesData.get( country ).latlng;

		inData.get( country ).forEach( ( amount, toCountry ) => {

			var c = countriesData.get( toCountry );
			if( c ) {
				var to = c.latlng;
				var g = join( { lat: from[ 0 ], lon: from[ 1 ] }, { lat: to[ 0 ], lon: to[ 1 ] }, amount / 1000000 );
				var line = new THREE.Mesh( g, lineInMaterial );
				world.add( line );
			} else {
				console.log( 'Missing country ', toCountry );
			}

		} );

		outData.get( country ).forEach( ( amount, toCountry ) => {

			var c = countriesData.get( toCountry );
			if( c ) {
				var to = c.latlng;
				var g = join( { lat: from[ 0 ], lon: from[ 1 ] }, { lat: to[ 0 ], lon: to[ 1 ] }, amount / 1000000 );
				var line = new THREE.Mesh( g, lineOutMaterial );
				world.add( line );
			} else {
				console.log( 'Missing country ', toCountry );
			}

		} );

		invalidate = true;

		/*
		var to = countriesData.get( 'FRA' ).latlng;
		var g = join( { lat: from[ 0 ], lon: from[ 1 ] }, { lat: to[ 0 ], lon: to[ 1 ] }, .1 );

		var line = new THREE.Mesh( g, material );
		world.add( line );

		var from = countriesData.get( 'USA' ).latlng;
		var to = countriesData.get( 'ESP' ).latlng;
		var g = join( { lat: from[ 0 ], lon: from[ 1 ] }, { lat: to[ 0 ], lon: to[ 1 ] }, .1 );

		var line = new THREE.Mesh( g, material );
		world.add( line );

		var from = countriesData.get( 'USA' ).latlng;
		var to = countriesData.get( 'PRT' ).latlng;
		var g = join( { lat: from[ 0 ], lon: from[ 1 ] }, { lat: to[ 0 ], lon: to[ 1 ] }, .1 );

		var line = new THREE.Mesh( g, material );
		world.add( line );*/

	}

	function buildMap() {

		var material = new THREE.LineBasicMaterial( { linewidth: 1 });
		var min = 10000000, max = -10000000;

		var lines = 0;
		mapData.forEach( ( territory, id ) => {

			territory.forEach( path => {

				path.lines.forEach( line => {

					lines += line.length;

				} );

			} );

		} );

		var lineGeometry = new THREE.BufferGeometry();
		var positions = new Float32Array( lines * 2 * 3 );
		var ptr = 0;

		mapData.forEach( ( territory, id ) => {

			territory.forEach( path => {

				path.lines.forEach( line => {

					/*var geometry = new THREE.Geometry();
					line.forEach( p => {
						var r = 100;
						var v = p.x * 2 * Math.PI / 360;
						var u = p.y * Math.PI / 180 + Math.PI / 2;
						if( v < min ) min = v;
						if( v > max ) max = v;
						var x = r * Math.sin( u ) * Math.cos( v );
						var y = r * Math.sin( u ) * Math.sin( v );
						var z = r * Math.cos( u );
						var vertex = new THREE.Vector3( x, y, z );
						geometry.vertices.push( vertex );
					} );

					var line = new THREE.MeshLine();
					line.setGeometry( geometry );

					var material = new THREE.MeshLineMaterial( {
						resolution: new THREE.Vector2( window.innerWidth, window.innerHeight ),
						sizeAttenuation: true,
						lineWidth: .1
					});

					var mesh = new THREE.Mesh( line.geometry, material );
					scene.add( mesh );*/

					for( var j = 0; j < line.length - 1; j++ ) {

						var p = line[ j ];
						if( p.y < min ) min = p.y;
						if( p.y > max ) max = p.x;

						var res = latLngToVec3( p.y, p.x );

						positions[ ptr ] = res.x;
						positions[ ptr + 1 ] = res.y;
						positions[ ptr + 2 ] = res.z;

						ptr += 3;

						var p = line[ j + 1 ];

						var res = latLngToVec3( p.y, p.x );

						positions[ ptr ] = res.x;
						positions[ ptr + 1 ] = res.y;
						positions[ ptr + 2 ] = res.z;

						ptr += 3;

					}

					var capital = countriesData.get( id );
					if( capital ) {

						var res = latLngToVec3( capital.latlng[ 0 ], capital.latlng[ 1 ] );

						var sphere = new THREE.Mesh(
							new THREE.BoxBufferGeometry( .1, .1, .1 ),
							new THREE.MeshBasicMaterial( { color: 0x0ff00ff })
						)
						sphere.position.copy( res );
						//world.add( sphere );
					} else {
						console.log( id + ' not found')
					}

					/*var shape = new THREE.Shape( line );

					var geometry = new THREE.ExtrudeGeometry( shape, { amount: .1, steps: 1, bevelEnabled: false } );
					var mesh = new THREE.Mesh(geometry, material);
					scene.add( mesh );*/


				})

			} );

		} );

		lineGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		lineGeometry.computeBoundingSphere();

		var mesh = new THREE.LineSegments( lineGeometry, material );
		mesh.fustrumCulled = false;
		world.add( mesh );

		invalidate = true;

		createConnections( 'GBR' );

		/*var exporter = new THREE.OBJExporter();
		var result = exporter.parse( scene );

		var blobModel = new Blob( [ result ], { type: 'text/plain' } );
		var url = URL.createObjectURL( blobModel );

		window.location = url;*/

		var geometry = new THREE.IcosahedronGeometry( 5, 6 );

		var loader = new THREE.TextureLoader()
		var heightMap = loader.load( 'assets/bathymetry_bw_composite_4k.jpg', _ => invalidate = true );
		var diffuseMap = loader.load( 'assets/bathymetry_diffuse_4k.jpg', _ => invalidate = true );

		var material = new THREE.RawShaderMaterial( {
			uniforms: {
				diffuseMap: { type: 't', value: diffuseMap },
				floorMap: { type: 't', value: heightMap }
			},
			vertexShader: document.getElementById( 'floor-vs' ).textContent,
			fragmentShader: document.getElementById( 'floor-fs' ).textContent,
			wireframe: !true,
			depthWrite: false,
			side: THREE.DoubleSide
		} );

		var mesh = new THREE.Mesh( geometry, material );
		mesh.scale.x = -1
		scene.add( mesh );

	}

	var hash = null;
	var invalidate = true;

	function hashCamera() {

		return `${camera.position.x}|${camera.position.y}|${camera.position.z}|${camera.rotation.x}|${camera.rotation.y}|${camera.rotation.z}`
	}

	function render( timestamp ) {

		controls.update();
		var newHash = hashCamera();
		if( hash != newHash ){
			invalidate = true;
			hash = newHash
		}

		/*raycaster.setFromCamera( centerVector, camera );
		var intersects = raycaster.intersectObjects( scene.children, true );
		if( intersects.length ) {
			nFocalDistance = 1 - intersects[ 0 ].distance / ( camera.far - camera.near );
		}*/

		/*DOFPass.params.focalDistance += ( nFocalDistance -  DOFPass.params.focalDistance) * .1;

		composer.reset();

		scene.overrideMaterial = depthMaterial;
		composer.render( scene, camera, null, depthTexture );
		DOFPass.params.tBias = depthTexture;

		scene.overrideMaterial = null;
		composer.render( scene, camera );

		composer.render( scene, camera );
		composer.pass( FXAAPass );
		composer.pass( rgbSplitPass );
		composer.pass( DOFPass );
		composer.pass( noisePass );

		composer.toScreen();*/

		//var time = - .001 * performance.now();
		//world.rotation.z = time;

		if( invalidate ) {
			effect.render( scene, camera );
			invalidate = false;
		}

		effect.requestAnimationFrame(render);

	}

	function onWindowResize() {

		effect.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		//composer.setSize( renderer.domElement.width, renderer.domElement.height );
		//depthTexture = WAGNER.Pass.prototype.getOfflineTexture( composer.width, composer.height, false );

		invalidate = true;

	}

	window.addEventListener( 'load', init );

</script>
</body>
</html>
