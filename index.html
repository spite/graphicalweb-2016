<!doctype html>
<html lang="en">
<head>

	<meta charset="utf-8">
	<title>World</title>

	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<link href='//fonts.googleapis.com/css?family=Raleway:400,200,600' rel='stylesheet' type='text/css'>

	<style>
		*{box-sizing: border-box; margin: 0; padding: 0; }
		#states{ position: absolute; left: 10px; top: 10px; list-style-type: none }
		#states li{ cursor: pointer; float :left; padding: 5px; background-color: rgba( 255, 255,255 ,.4); margin: 0 2px 2px 0;}
	</style>
</head>
<body>

<ul id="states" ></ul>

<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/pathseg.js"></script>
<script src="js/MapMesh.js"></script>
<script src="js/THREE.MeshLine.js"></script>
<script src="js/OBJExporter.js"></script>

<script src="Wagner/Wagner.js"></script>
<script src="Wagner/Wagner.base.js"></script>
<script src="Wagner/ShaderLoader.js"></script>

<script id="floor-vs" type="x-shader/x-vertex" >
precision highp float;

attribute vec3 position;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

uniform sampler2D floorMap;

varying vec2 vUv;

void main() {

	vUv = uv;

	vec4 c = texture2D( floorMap, uv );
	vec3 dir = normalize( position );

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position + 10. * c.r * dir, 1. );

}

</script>

<script id="floor-fs" type="x-shader/x-fragment" >
precision highp float;

uniform sampler2D floorMap;
uniform sampler2D diffuseMap;

varying vec2 vUv;

void main() {

	vec4 d = texture2D( diffuseMap, vUv );
	vec4 h = texture2D( floorMap, vUv );

	vec4 c = mix( vec4( 0., 119., 190., 255. ) / 255. * h.r, d, smoothstep( .45, .55, h.r ) );

	gl_FragColor = vec4( c.rgb, 1. );

}

</script>

<script>

	'use strict'

	WAGNER.vertexShadersPath = 'Wagner/vertex-shaders';
	WAGNER.fragmentShadersPath = 'Wagner/fragment-shaders';
	WAGNER.assetsPath = 'Wagner/assets/';

	/*WAGNER.BokehPoisonPass = function() {

		WAGNER.Pass.call( this );
		WAGNER.log( 'BokehPoison Pass constructor' );
		this.loadShader( 'bokeh-poison-dof-fs.glsl' );

		this.params.amount = 10;
		this.params.radius = 1;
		this.params.tBias = null
		this.params.focalDistance = 1;
		this.params.aperture = 1;

	};

	WAGNER.BokehPoisonPass.prototype = Object.create( WAGNER.Pass.prototype );

	WAGNER.BokehPoisonPass.prototype.run = function( c ) {

		this.shader.uniforms.amount.value = this.params.amount;
		this.shader.uniforms.radius.value = this.params.radius;
		this.shader.uniforms.focalDistance.value = this.params.focalDistance;
		this.shader.uniforms.aperture.value = this.params.aperture;
		this.shader.uniforms.tBias.value = this.params.tBias;
		c.pass( this.shader );

	};*/

	var composer;
	var FXAAPass, DOFPass, noisePass, rgbSplitPass;
	var raycaster = new THREE.Raycaster();
	var centerVector = new THREE.Vector2( 0, 0 );

	var focalDistance = 0;
	var nFocalDistance = 0;

	var scene, camera, controls, renderer, controls;
	var map;
	var raycaster = new THREE.Raycaster();
	var light1, light2, helper;

	var material = new THREE.MeshStandardMaterial( { color: 0xffffff, metalness: 1, roughness: .8 } );
	//material = new THREE.MeshNormalMaterial();
	var statesDiv = document.getElementById( 'states' );
	var nTarget = new THREE.Vector3( 0, 0, 0 );
	var nPosition = new THREE.Vector3( 0, 500, 100 );

	var stateMeshes = {}

	var depthMaterial = new THREE.MeshBasicMaterial();
	var depthTexture = null;

	var world = new THREE.Object3D();

	/*var sL = new ShaderLoader()
	sL.add( 'depth-vs', 'bower_components/Wagner/vertex-shaders/packed-depth-vs.glsl' );
	sL.add( 'depth-fs', 'bower_components/Wagner/fragment-shaders/packed-depth-fs.glsl' );
	sL.load();
	sL.onLoaded( function() {
		depthMaterial = new THREE.ShaderMaterial( {
			uniforms: {
				mNear: { type: 'f', value: camera.near },
				mFar: { type: 'f', value: camera.far }
			},
			vertexShader: this.get( 'depth-vs' ),
			fragmentShader: this.get( 'depth-fs' ),
			shading: THREE.SmoothShading,
			side: THREE.DoubleSide
		} );
	} );*/

	function init() {

		scene = new THREE.Scene();
		var aspectRatio = window.innerWidth / window.innerHeight;
		camera = new THREE.PerspectiveCamera( 75, aspectRatio, .01, 3000 );
		camera.target = new THREE.Vector3();
		camera.position.set( 0, 0, 0.0001 );
		//camera.position.set( 100, 100, 100 );

		renderer = new THREE.WebGLRenderer( { antialias: true });
		document.body.appendChild( renderer.domElement );
		var pixelRatioScale = 1;
		renderer.setPixelRatio( pixelRatioScale * window.devicePixelRatio );
		renderer.setClearColor( 0 );

		composer = new WAGNER.Composer( renderer, { useRGBA: false } );
		//vignettePass = new WAGNER.Vignette2Pass();
		//vignettePass.params.reduction = 2;
		FXAAPass = new WAGNER.FXAAPass();
		//DOFPass = new WAGNER.BokehPoisonPass();
		//DOFPass.params.focalDistance = .5;
		DOFPass = new WAGNER.DOFPass();
		DOFPass.params.aperture = .1;
		DOFPass.params.blurAmount = .1;

		noisePass = new WAGNER.NoisePass();
		noisePass.params.amount = .01;

		rgbSplitPass = new WAGNER.RGBSplitPass();
		rgbSplitPass.params.delta.set( pixelRatioScale * 20, pixelRatioScale * 20 );

		controls = new THREE.OrbitControls( camera );

		scene.add( world );
		//world.rotation.y = .1;
		//world.rotation.x = Math.PI / 2;
		//world.scale.x = -1;

		window.addEventListener( 'resize', onWindowResize );

		onWindowResize();

		window.addEventListener( 'keydown', function( e ) {
			/*if( e.keyCode == 32 ) {
				startTime = Date.now();
				audio.currentTime = 0;
			}*/
		} )

		var s = 2048;

		light1 = new THREE.SpotLight( 0xffffff );
		light1.position.set( -100, 300, -100 );
		light1.penumbra = .25
		scene.add( light1 );

		light1.shadow.mapSize.width = s;
		light1.shadow.mapSize.height = s;

		light1.shadow.camera.near = 1;
		light1.shadow.camera.far = 400;
		light1.shadow.bias = -.0000025
		light1.castShadow = true;

		light2 = new THREE.SpotLight( 0xffffff );
		light2.position.set( 300, 300, 100 );
		light2.penumbra = .25
		scene.add( light2 );

		light2.shadow.mapSize.width = s;
		light2.shadow.mapSize.height = s;

		light2.shadow.camera.near = 1;
		light2.shadow.camera.far = 400;
		light2.shadow.bias = -.000005
		light2.castShadow = true;

		renderer.shadowMap.type = THREE.PCFSoftShadowMap
		renderer.shadowMap.enabled = true;

		render();
		loadMap();

	}

	var countriesData, mapData;

	function createCountriesMap( data ) {

		countriesData = new Map();

		data.forEach( c => {
			countriesData.set( c.cca3, c );
		} );

	}

	function loadMap() {

		Promise.all( [
			fetch( 'assets/countries.json' ).then( res => res.json() ).then( res => createCountriesMap( res ) ),
			create().then( res => mapData = res )
		] ).then( _ => buildMap() );

	}

	function latLngToVec3( lat, lon ) {

		lat = Math.max( - 85, Math.min( 85, lat ) );
		var phi = ( 90 - lat ) * Math.PI / 180;
		var theta = ( 180 - lon ) * Math.PI / 180;
		var d = 100;
		var x = -d * Math.sin( phi ) * Math.cos( theta );
		var y = d * Math.cos( phi );
		var z = d * Math.sin( phi ) * Math.sin( theta );

		return new THREE.Vector3( x, y, z );

	}

	function buildMap() {

		var material = new THREE.LineBasicMaterial( { linewidth: 20 });
		var min = 10000000, max = -10000000;

		mapData.forEach( ( territory, id ) => {

			territory.forEach( path => {

				path.lines.forEach( line => {

					/*var geometry = new THREE.Geometry();
					line.forEach( p => {
						var r = 100;
						var v = p.x * 2 * Math.PI / 360;
						var u = p.y * Math.PI / 180 + Math.PI / 2;
						if( v < min ) min = v;
						if( v > max ) max = v;
						var x = r * Math.sin( u ) * Math.cos( v );
						var y = r * Math.sin( u ) * Math.sin( v );
						var z = r * Math.cos( u );
						var vertex = new THREE.Vector3( x, y, z );
						geometry.vertices.push( vertex );
					} );

					var line = new THREE.MeshLine();
					line.setGeometry( geometry );

					var material = new THREE.MeshLineMaterial( {
						resolution: new THREE.Vector2( window.innerWidth, window.innerHeight ),
						sizeAttenuation: true,
						lineWidth: .1
					});

					var mesh = new THREE.Mesh( line.geometry, material );
					scene.add( mesh );*/

					var geometry = new THREE.BufferGeometry();
					var positions = new Float32Array( line.length * 3 );
					var ptr = 0;

					line.forEach( p => {

						if( p.y < min ) min = p.y;
						if( p.y > max ) max = p.x;

						var res = latLngToVec3( p.y, p.x );

						positions[ ptr ] = res.x;
						positions[ ptr + 1 ] = res.y;
						positions[ ptr + 2 ] = res.z;

						ptr += 3;

					} );

					geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

					geometry.computeBoundingSphere();

					var mesh = new THREE.Line( geometry, material );
					world.add( mesh );

					var capital = countriesData.get( id );
					if( capital ) {

						var res = latLngToVec3( capital.latlng[ 0 ], capital.latlng[ 1 ] );

						var sphere = new THREE.Mesh(
							new THREE.BoxBufferGeometry( 1, 1, 1 ),
							new THREE.MeshBasicMaterial( { color: 0x0ff00ff })
						)
						sphere.position.copy( res );
						world.add( sphere );
					} else {
						console.log( id + ' not found')
					}

					/*var shape = new THREE.Shape( line );

					var geometry = new THREE.ExtrudeGeometry( shape, { amount: .1, steps: 1, bevelEnabled: false } );
					var mesh = new THREE.Mesh(geometry, material);
					scene.add( mesh );*/


				})

			} );

		} );

		console.log( min, max );

		invalidate = true;

		/*var exporter = new THREE.OBJExporter();
		var result = exporter.parse( scene );

		var exporter = new THREE.OBJExporter( );
		var blobModel = new Blob( [ result ], { type: 'text/plain' } );
		var url = URL.createObjectURL( blobModel );

		window.location = url;*/

		var geometry = new THREE.IcosahedronGeometry( 99, 4 );
		var material = new THREE.MeshBasicMaterial( { color: 0, opacity: .75, transparent: true, polygonOffset: false,
polygonOffsetFactor: 10 } );
		var mesh = new THREE.Mesh( geometry, material );
		//scene.add( mesh );

//		var geometry = new THREE.SphereGeometry( 110, 36, 36 );
		var geometry = new THREE.IcosahedronGeometry( 110, 6 );

		/*for ( var i = 0, l = geometry.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			for ( var j = 0, jl = geometry.faceVertexUvs[ 0 ][ i ].length; j < jl; j ++ ) {

				var uv = geometry.faceVertexUvs[ 0 ][ i ][ j ];

				var a = uv.y * Math.PI - Math.PI / 2;
				a = Math.sin(a);
				uv.y = 0.5 - Math.log( ( 1 + a ) / ( 1 - a ) ) / ( 4 * Math.PI );
				uv.y = 1 - uv.y;
				uv.x = 1 - uv.x;

			}

		}

		geometry.uvsNeedUpdate = true;*/

		var material = new THREE.RawShaderMaterial( {
			uniforms: {
				diffuseMap: { type: 't', value: THREE.ImageUtils.loadTexture( 'assets/bathymetry_diffuse_4k.jpg' ) },
				floorMap: { type: 't', value: THREE.ImageUtils.loadTexture( 'assets/bathymetry_bw_composite_4k.jpg' ) }
			},
			vertexShader: document.getElementById( 'floor-vs' ).textContent,
			fragmentShader: document.getElementById( 'floor-fs' ).textContent,
			wireframe: !true,
			side: THREE.DoubleSide
		} );

		var mesh = new THREE.Mesh( geometry, material );
		mesh.scale.x = -1
		scene.add( mesh );

	}

	var hash = null;
	var invalidate = true;

	function hashCamera() {

		return `${camera.position.x}|${camera.position.y}|${camera.position.z}|${camera.rotation.x}|${camera.rotation.y}|${camera.rotation.z}`
	}

	function render( timestamp ) {

		controls.update();
		var newHash = hashCamera();
		if( hash != newHash ){
			invalidate = true;
			hash = newHash
		}

		/*raycaster.setFromCamera( centerVector, camera );
		var intersects = raycaster.intersectObjects( scene.children, true );
		if( intersects.length ) {
			nFocalDistance = 1 - intersects[ 0 ].distance / ( camera.far - camera.near );
		}*/

		/*DOFPass.params.focalDistance += ( nFocalDistance -  DOFPass.params.focalDistance) * .1;

		composer.reset();

		scene.overrideMaterial = depthMaterial;
		composer.render( scene, camera, null, depthTexture );
		DOFPass.params.tBias = depthTexture;

		scene.overrideMaterial = null;
		composer.render( scene, camera );

		composer.render( scene, camera );
		composer.pass( FXAAPass );
		composer.pass( rgbSplitPass );
		composer.pass( DOFPass );
		composer.pass( noisePass );

		composer.toScreen();*/

		//var time = - .001 * performance.now();
		//world.rotation.z = time;

		if( invalidate ) {
			renderer.render( scene, camera );
			invalidate = false;
		}

		requestAnimationFrame(render);

	}

	function onWindowResize() {

		renderer.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		//composer.setSize( renderer.domElement.width, renderer.domElement.height );
		//depthTexture = WAGNER.Pass.prototype.getOfflineTexture( composer.width, composer.height, false );

		invalidate = true;

	}

	window.addEventListener( 'load', init );

</script>
</body>
</html>
